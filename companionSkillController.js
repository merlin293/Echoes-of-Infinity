// SOUBOR: companionSkillController.js

// DOM elementy pro mod√°ln√≠ okno budou definov√°ny a inicializov√°ny v uiController.js
// nap≈ô. companionSkillModal, companionSkillModalTitle, modalCompanionEssenceDisplay,
// companionSkillsContainer, closeCompanionSkillModalButton;

// Glob√°ln√≠ promƒõnn√° pro tooltip element (bude inicializov√°na v uiController.js)
// let companionSkillTooltipElement;

/**
 * P≈ôid√° hr√°ƒçi Esence Spoleƒçn√≠k≈Ø.
 * @param {number} amount - Mno≈æstv√≠ Esenc√≠ Spoleƒçn√≠k≈Ø k p≈ôid√°n√≠.
 */
function gainCompanionEssence(amount) {
    if (!gameState) return;
    gameState.companionEssence = (gameState.companionEssence || 0) + amount;
    gameState.lifetimeStats.companionEssenceCollectedTotal = (gameState.lifetimeStats.companionEssenceCollectedTotal || 0) + amount;

    if (typeof showMessageBox === 'function') {
        showMessageBox(`Z√≠skal jsi ${amount} Esenc√≠ Spoleƒçn√≠k≈Ø!`, false, 2000);
    }
    if (typeof updateDailyQuestProgress === 'function') {
        updateDailyQuestProgress('companionEssenceCollected', amount);
    }
    if (typeof updateUI === 'function') updateUI();
    if (typeof companionSkillModal !== 'undefined' && companionSkillModal && !companionSkillModal.classList.contains('hidden') && typeof modalCompanionEssenceDisplay !== 'undefined' && modalCompanionEssenceDisplay) {
        modalCompanionEssenceDisplay.textContent = formatNumber(gameState.companionEssence);
    }
}

/**
 * Otev≈ôe mod√°ln√≠ okno se stromem dovednost√≠ pro dan√©ho spoleƒçn√≠ka.
 * @param {string} companionId - ID spoleƒçn√≠ka.
 */
function openCompanionSkillTreeModalUI(companionId) {
    const companion = allCompanions[companionId];
    if (!companion) {
        console.error(`Spoleƒçn√≠k s ID ${companionId} nebyl nalezen pro zobrazen√≠ stromu dovednost√≠.`);
        return;
    }

    if (companionSkillModal && companionSkillModalTitle && modalCompanionEssenceDisplay && companionSkillsContainer) {
        companionSkillModalTitle.textContent = `Dovednosti: ${companion.icon} ${companion.name}`;
        modalCompanionEssenceDisplay.textContent = formatNumber(gameState.companionEssence);
        renderCompanionSkillTreeUI(companionId, companionSkillsContainer);

        companionSkillModal.dataset.companionId = companionId;

        openModal(companionSkillModal);
    } else {
        console.error("DOM elementy pro mod√°ln√≠ okno dovednost√≠ spoleƒçn√≠ka nebyly nalezeny/inicializov√°ny v uiController.");
    }
}


/**
 * Generuje texty pro n√°hled efektu dovednosti spoleƒçn√≠ka.
 * @param {string} companionId - ID spoleƒçn√≠ka.
 * @param {string} skillId - ID dovednosti.
 * @returns {object} - Objekt s texty pro tooltip.
 */
function getCompanionSkillEffectPreviewText(companionId, skillId) {
    const companionDef = allCompanions[companionId];
    if (!companionDef || !companionDef.skillTree || !companionDef.skillTree[skillId]) {
        return { name: "Nezn√°m√° dovednost", currentLevelText: "", currentEffectText: "Chyba: Definice nenalezena", nextEffectText: "", costText: "" };
    }
    const skillDef = companionDef.skillTree[skillId];
    const currentSkillLevel = (gameState.companionSkillLevels[companionId] && gameState.companionSkillLevels[companionId][skillId]) ? gameState.companionSkillLevels[companionId][skillId] : 0;

    let currentEffectText = "";
    let nextEffectText = "";

    // Funkce pro form√°tov√°n√≠ bonusu (podobn√° t√© v renderCompanionSkillTreeUI)
    const formatBonus = (level) => {
        if (level === 0 && skillDef.effectType !== 'global_player_damage_percent_if_active' && skillDef.effectType !== 'global_player_gold_multiplier_percent_if_active' && skillDef.effectType !== 'global_companion_passive_percent_flat_boost' && skillDef.effectType !== 'global_companion_essence_drop_chance_additive_percent') { // Pro nƒõkter√© glob√°ln√≠ bonusy chceme uk√°zat 0% i na levelu 0
             if (skillDef.effectType !== 'companion_gold_on_hit_chance') { // ≈†ance na zlato se zobraz√≠ i na 0
                return "Neaktivn√≠";
             }
        }
        let bonusVal = level * skillDef.effectValuePerLevel;
        if (skillDef.effectType.includes('percent') || skillDef.effectType === 'companion_gold_on_hit_chance' || skillDef.effectType === 'global_companion_essence_drop_chance_additive_percent') {
            return `+${formatNumber(bonusVal * 100, 2)}%`;
        } else if (skillDef.effectType === 'global_companion_passive_percent_flat_boost') {
             return `+${formatNumber(bonusVal * 100, 4)}%`; // Pro velmi mal√© hodnoty
        }
        return `+${formatNumber(bonusVal, 2)}`;
    };

    currentEffectText = `Nyn√≠: ${skillDef.description.replace('{bonusValue}', formatBonus(currentSkillLevel).replace('+',''))}`;


    if (currentSkillLevel < skillDef.maxLevel) {
        nextEffectText = `Dal≈°√≠ √∫r.: ${skillDef.description.replace('{bonusValue}', formatBonus(currentSkillLevel + 1).replace('+',''))}`;
    } else {
        nextEffectText = "Maxim√°ln√≠ √∫rove≈à";
    }
     // Zjednodu≈°en√≠, aby se nezobrazovalo "Nyn√≠: popis +0%" ale sp√≠≈°e "Nyn√≠: popis efektu"
    if (currentSkillLevel === 0 && (skillDef.effectType !== 'companion_gold_on_hit_chance' && skillDef.effectType !== 'global_companion_essence_drop_chance_additive_percent')) { // Pro nƒõkter√© typy chceme zobrazit i "0%"
        currentEffectText = "Efekt: Neaktivn√≠";
    }


    return {
        name: `${skillDef.icon || 'üîß'} ${skillDef.name}`,
        currentLevelText: `√örove≈à: ${currentSkillLevel}/${skillDef.maxLevel}`,
        currentEffectText,
        nextEffectText,
        costText: currentSkillLevel < skillDef.maxLevel ? `Cena dal≈°√≠ √∫rovnƒõ: ${formatNumber(skillDef.cost(currentSkillLevel))} Esenc√≠ Spol.` : ""
    };
}

/**
 * Zobraz√≠ tooltip s informacemi o dovednosti spoleƒçn√≠ka.
 * @param {string} companionId - ID spoleƒçn√≠ka.
 * @param {string} skillId - ID dovednosti.
 * @param {MouseEvent} event - Ud√°lost my≈°i pro pozicov√°n√≠.
 */
function showCompanionSkillTooltip(companionId, skillId, event) {
    if (!companionSkillTooltipElement) { // companionSkillTooltipElement z uiController.js
        return;
    }
    const preview = getCompanionSkillEffectPreviewText(companionId, skillId);
    let tooltipHTML = `
        <strong class="companionskill-tooltip-name">${preview.name}</strong>
        <p class="companionskill-tooltip-level">${preview.currentLevelText}</p>
        <hr class="companionskill-tooltip-hr">
        <p class="companionskill-tooltip-effect">${preview.currentEffectText}</p>`;
    if (preview.nextEffectText) {
        tooltipHTML += `<p class="companionskill-tooltip-effect-next">${preview.nextEffectText}</p>`;
    }
    if (preview.costText) {
         tooltipHTML += `<p class="companionskill-tooltip-cost">${preview.costText}</p>`;
    }

    companionSkillTooltipElement.innerHTML = tooltipHTML;
    companionSkillTooltipElement.classList.remove('hidden');
    updateCompanionSkillTooltipPosition(event);
}

/**
 * Skryje tooltip dovednosti spoleƒçn√≠ka.
 */
function hideCompanionSkillTooltip() {
    if (companionSkillTooltipElement) {
        companionSkillTooltipElement.classList.add('hidden');
    }
}

/**
 * Aktualizuje pozici tooltipu dovednosti spoleƒçn√≠ka.
 * @param {MouseEvent} event - Ud√°lost my≈°i.
 */
function updateCompanionSkillTooltipPosition(event) {
    if (!companionSkillTooltipElement || companionSkillTooltipElement.classList.contains('hidden')) return;
    const tooltipWidth = companionSkillTooltipElement.offsetWidth;
    const tooltipHeight = companionSkillTooltipElement.offsetHeight;
    let x = event.clientX + 15;
    let y = event.clientY + 15;
    const viewportRight = window.innerWidth;
    const viewportBottom = window.innerHeight;

    if (x + tooltipWidth > viewportRight - 10) {
        x = event.clientX - tooltipWidth - 15;
    }
    if (y + tooltipHeight > viewportBottom - 10) {
        y = event.clientY - tooltipHeight - 15;
    }
    x = Math.max(10, x);
    y = Math.max(10, y);
    companionSkillTooltipElement.style.left = `${x}px`;
    companionSkillTooltipElement.style.top = `${y}px`;
}


/**
 * Vykresl√≠ strom dovednost√≠ pro dan√©ho spoleƒçn√≠ka do poskytnut√©ho kontejneru.
 * @param {string} companionId - ID spoleƒçn√≠ka.
 * @param {HTMLElement} container - HTML element, do kter√©ho se maj√≠ dovednosti vykreslit.
 */
function renderCompanionSkillTreeUI(companionId, container) {
    if (!container) {
        console.error("Kontejner pro vykreslen√≠ dovednost√≠ spoleƒçn√≠ka nebyl poskytnut.");
        return;
    }
    container.innerHTML = '';

    const companionDef = allCompanions[companionId];
    const companionInstance = gameState.ownedCompanions[companionId];

    if (!companionDef || !companionInstance) {
        container.innerHTML = '<p class="text-xs text-gray-400 text-center">Spoleƒçn√≠k nen√≠ vlastnƒõn nebo nebyl nalezen.</p>';
        return;
    }
    if (!companionDef.skillTree || Object.keys(companionDef.skillTree).length === 0) {
        container.innerHTML = '<p class="text-xs text-gray-400 text-center">Tento spoleƒçn√≠k nem√° ≈æ√°dn√© dovednosti.</p>';
        return;
    }

    for (const skillId in companionDef.skillTree) {
        if (companionDef.skillTree.hasOwnProperty(skillId)) {
            const skillDef = companionDef.skillTree[skillId];
            const currentSkillLevel = (gameState.companionSkillLevels[companionId] && gameState.companionSkillLevels[companionId][skillId]) ? gameState.companionSkillLevels[companionId][skillId] : 0;

            const skillDiv = document.createElement('div');
            skillDiv.classList.add('talent-item'); // Pou≈æijeme stejn√Ω styl jako pro talenty pro konzistenci

            // P≈ôid√°n√≠ event listener≈Ø pro tooltip
            skillDiv.addEventListener('mouseenter', (event) => showCompanionSkillTooltip(companionId, skillId, event));
            skillDiv.addEventListener('mouseleave', hideCompanionSkillTooltip);
            skillDiv.addEventListener('mousemove', updateCompanionSkillTooltipPosition);


            let bonusValue = currentSkillLevel * skillDef.effectValuePerLevel;
            if (isNaN(bonusValue)) {
                bonusValue = 0;
            }
            let bonusTextForDisplay; // Pro p≈ô√≠m√Ω popis v UI

            if (skillDef.effectType.includes('percent') || skillDef.effectType === 'companion_gold_on_hit_chance' || skillDef.effectType === 'global_companion_essence_drop_chance_additive_percent') {
                bonusTextForDisplay = formatNumber(bonusValue * 100, 2);
            } else if (skillDef.effectType === 'global_companion_passive_percent_flat_boost') {
                bonusTextForDisplay = formatNumber(bonusValue * 100, 4);
            }
            else {
                bonusTextForDisplay = formatNumber(bonusValue, (Math.abs(bonusValue) < 1 && bonusValue !== 0) ? 4 : 2);
            }

            const nameP = document.createElement('p');
            nameP.classList.add('talent-name'); // Pou≈æijeme .talent-name
            nameP.textContent = `${skillDef.icon || 'üîß'} ${skillDef.name} (√ör. ${currentSkillLevel}/${skillDef.maxLevel})`;
            skillDiv.appendChild(nameP);

            const descP = document.createElement('p');
            descP.classList.add('talent-description'); // Pou≈æijeme .talent-description
            descP.textContent = skillDef.description.replace('{bonusValue}', bonusTextForDisplay);
            skillDiv.appendChild(descP);

            const costP = document.createElement('p');
            costP.classList.add('talent-level-cost'); // Pou≈æijeme .talent-level-cost
            costP.id = `skill-cost-${companionId}-${skillId}`;
            skillDiv.appendChild(costP); // CostP se napln√≠ v updateCompanionSkillButtonState

            if (currentSkillLevel < skillDef.maxLevel) {
                const upgradeButton = document.createElement('button');
                upgradeButton.classList.add('talent-upgrade-button'); // Pou≈æijeme .talent-upgrade-button
                upgradeButton.textContent = 'Vylep≈°it Dovednost';
                upgradeButton.dataset.companionId = companionId;
                upgradeButton.dataset.skillId = skillId;
                upgradeButton.onclick = () => upgradeCompanionSkill(companionId, skillId);
                skillDiv.appendChild(upgradeButton);
                updateCompanionSkillButtonState(upgradeButton, companionId, skillId, skillDef, currentSkillLevel, costP);
            } else {
                costP.textContent = "Maxim√°ln√≠ √∫rove≈à dovednosti";
            }
            container.appendChild(skillDiv);
        }
    }
}

/**
 * Aktualizuje stav tlaƒç√≠tka pro vylep≈°en√≠ dovednosti spoleƒçn√≠ka (cenu a zda je aktivn√≠).
 * @param {HTMLButtonElement} button - Tlaƒç√≠tko pro vylep≈°en√≠.
 * @param {string} companionId - ID spoleƒçn√≠ka.
 * @param {string} skillId - ID dovednosti.
 * @param {object} skillDef - Definice dovednosti z config.js.
 * @param {number} currentSkillLevel - Aktu√°ln√≠ √∫rove≈à dovednosti.
 * @param {HTMLElement} costTextPElement - HTML element <p> pro zobrazen√≠ ceny.
 */
function updateCompanionSkillButtonState(button, companionId, skillId, skillDef, currentSkillLevel, costTextPElement) {
    if (!button || !costTextPElement) {
        if(costTextPElement) costTextPElement.textContent = "Chyba naƒç√≠t√°n√≠ ceny.";
        return;
    }

    if (currentSkillLevel >= skillDef.maxLevel) {
        button.disabled = true;
        button.textContent = 'Max. √örove≈à';
        costTextPElement.textContent = 'Maxim√°ln√≠ √∫rove≈à dovednosti';
        return;
    }

    const cost = skillDef.cost(currentSkillLevel);

    let prerequisiteMet = true;
    let prerequisiteText = "";
    if (skillDef.requires) {
        const reqSkillId = skillDef.requires.skill;
        const reqSkillLevel = skillDef.requires.level;
        const currentReqSkillLevel = (gameState.companionSkillLevels && gameState.companionSkillLevels[companionId] && gameState.companionSkillLevels[companionId][reqSkillId])
                                     ? gameState.companionSkillLevels[companionId][reqSkillId]
                                     : 0;
        if (currentReqSkillLevel < reqSkillLevel) {
            prerequisiteMet = false;
            const requiredSkillDef = (allCompanions && allCompanions[companionId] && allCompanions[companionId].skillTree && allCompanions[companionId].skillTree[reqSkillId])
                                     ? allCompanions[companionId].skillTree[reqSkillId]
                                     : { name: "Nezn√°m√° dovednost" };
            prerequisiteText = `<br><span class="text-xs text-red-400">Vy≈æaduje: ${requiredSkillDef.name} (√ör. ${reqSkillLevel})</span>`;
        }
    }
    costTextPElement.innerHTML = `Cena: ${formatNumber(cost)} Esenc√≠ Spol.` + prerequisiteText;

    button.disabled = gameState.companionEssence < cost || !prerequisiteMet;
    button.textContent = 'Vylep≈°it Dovednost';
}


/**
 * Zpracuje n√°kup nebo vylep≈°en√≠ dovednosti spoleƒçn√≠ka.
 * @param {string} companionId - ID spoleƒçn√≠ka.
 * @param {string} skillId - ID dovednosti.
 */
function upgradeCompanionSkill(companionId, skillId) {
    const companionDef = allCompanions[companionId];
    if (!companionDef || !companionDef.skillTree || !companionDef.skillTree[skillId]) {
        console.error(`Dovednost ${skillId} pro spoleƒçn√≠ka ${companionId} nebyla nalezena.`);
        return;
    }
    const skillDef = companionDef.skillTree[skillId];
    const currentSkillLevel = (gameState.companionSkillLevels[companionId] && gameState.companionSkillLevels[companionId][skillId]) ? gameState.companionSkillLevels[companionId][skillId] : 0;

    if (currentSkillLevel >= skillDef.maxLevel) {
        if (typeof showMessageBox === 'function') showMessageBox("Tato dovednost je ji≈æ na maxim√°ln√≠ √∫rovni!", true);
        return;
    }

    if (skillDef.requires) {
        const reqSkillId = skillDef.requires.skill;
        const reqSkillLevel = skillDef.requires.level;
        const currentReqSkillLevel = (gameState.companionSkillLevels[companionId] && gameState.companionSkillLevels[companionId][reqSkillId]) ? gameState.companionSkillLevels[companionId][reqSkillId] : 0;
        if (currentReqSkillLevel < reqSkillLevel) {
            if (typeof showMessageBox === 'function') showMessageBox("Nejprve vylep≈°ete po≈æadovanou dovednost!", true);
            return;
        }
    }

    const cost = skillDef.cost(currentSkillLevel);
    if (gameState.companionEssence >= cost) {
        gameState.companionEssence -= cost;
        if (!gameState.companionSkillLevels[companionId]) {
            gameState.companionSkillLevels[companionId] = {};
        }
        gameState.companionSkillLevels[companionId][skillId] = currentSkillLevel + 1;

        if (typeof showMessageBox === 'function') showMessageBox(`Dovednost "${skillDef.name}" spoleƒçn√≠ka ${companionDef.name} vylep≈°ena na √∫rove≈à ${currentSkillLevel + 1}!`, false);
        if (typeof soundManager !== 'undefined') soundManager.playSound('upgrade', 'A#4', '16n');

        if (typeof updateTotalCompanionPassivePercentOnGameState === 'function') {
            updateTotalCompanionPassivePercentOnGameState();
        }
        if (typeof calculateEffectiveStats === 'function') calculateEffectiveStats();
        if (typeof updateUI === 'function') updateUI();

        if (typeof companionSkillsContainer !== 'undefined' && companionSkillsContainer && companionSkillModal && !companionSkillModal.classList.contains('hidden')) {
             renderCompanionSkillTreeUI(companionId, companionSkillsContainer);
             if(typeof modalCompanionEssenceDisplay !== 'undefined' && modalCompanionEssenceDisplay) {
                modalCompanionEssenceDisplay.textContent = formatNumber(gameState.companionEssence);
             }
        }
    } else {
        if (typeof showMessageBox === 'function') showMessageBox("Nedostatek Esenc√≠ Spoleƒçn√≠k≈Ø!", true);
    }
}

/**
 * Z√≠sk√° bonus z aktivn√≠ dovednosti spoleƒçn√≠ka.
 * @param {string} companionId - ID spoleƒçn√≠ka.
 * @param {string} effectType - Typ efektu, kter√Ω hled√°me.
 * @returns {number} - Celkov√° hodnota bonusu z dan√©ho typu efektu pro spoleƒçn√≠ka.
 */
function getCompanionSkillBonus(companionId, effectType) {
    let totalBonus = 0;
    if (!gameState.companionSkillLevels || !gameState.companionSkillLevels[companionId] || !allCompanions[companionId] || !allCompanions[companionId].skillTree) {
        return 0;
    }

    const skills = gameState.companionSkillLevels[companionId];
    const skillTreeDef = allCompanions[companionId].skillTree;

    for (const skillId in skills) {
        if (skills.hasOwnProperty(skillId) && skillTreeDef[skillId] && skillTreeDef[skillId].effectType === effectType) {
            const skillLevel = skills[skillId];
            if (skillLevel > 0) {
                totalBonus += skillLevel * skillTreeDef[skillId].effectValuePerLevel;
            }
        }
    }
    return totalBonus;
}
